package main

import (
	"fmt"
	"os"
	"path/filepath"
	"strings"
)

// TerraformResource represents a Terraform resource or data source
type TerraformResource struct {
	Type       string
	Name       string
	Attributes map[string]interface{}
	IsData     bool   // true for data sources, false for resources
	ID         string // stored separately for import, not written to .tf files
}

// TerraformGenerator handles the generation of Terraform files
type TerraformGenerator struct {
	outputDir      string
	config         *Config
	resources      []TerraformResource
	importCommands []ImportCommand
}

// ImportCommand represents a terraform import command to be executed
type ImportCommand struct {
	ResourceAddress string
	ResourceID      string
}

// NewTerraformGenerator creates a new Terraform generator
func NewTerraformGenerator(outputDir string, config *Config) *TerraformGenerator {
	return &TerraformGenerator{
		outputDir:      outputDir,
		config:         config,
		resources:      make([]TerraformResource, 0),
		importCommands: make([]ImportCommand, 0),
	}
}

// AddResource adds a resource to be generated and queues terraform import
func (tg *TerraformGenerator) AddResource(resourceType, name string, attributes map[string]interface{}) {
	// Extract and store the ID separately
	var resourceID string
	if id, exists := attributes["id"]; exists {
		if idStr, ok := id.(string); ok {
			resourceID = idStr
		}
	}

	tg.resources = append(tg.resources, TerraformResource{
		Type:       resourceType,
		Name:       name,
		Attributes: attributes,
		IsData:     false,
		ID:         resourceID,
	})
	fmt.Printf("  Added %s resource: %s\n", resourceType, name)

	// Queue terraform import for this resource
	tg.queueTerraformImport(resourceType, name, resourceID)
}

// AddDataSource adds a data source to be generated
func (tg *TerraformGenerator) AddDataSource(dataType, name string, attributes map[string]interface{}) {
	tg.resources = append(tg.resources, TerraformResource{
		Type:       dataType,
		Name:       name,
		Attributes: attributes,
		IsData:     true,
	})
	fmt.Printf("  Added %s data source: %s\n", dataType, name)
}

// GenerateFiles generates all Terraform files
func (tg *TerraformGenerator) GenerateFiles() error {
	fmt.Printf("\nGenerating Terraform files...\n")

	// Create output directory
	err := os.MkdirAll(tg.outputDir, 0755)
	if err != nil {
		return fmt.Errorf("failed to create output directory: %w", err)
	}

	fmt.Printf("Total resources to generate: %d\n", len(tg.resources))

	// Group resources by type
	resourcesByType := make(map[string][]TerraformResource)
	for _, resource := range tg.resources {
		resourcesByType[resource.Type] = append(resourcesByType[resource.Type], resource)
	}

	// Generate a file for each resource type
	for resourceType, resources := range resourcesByType {
		fmt.Printf("Generating %s.tf with %d resources...\n", resourceType, len(resources))
		err := tg.generateResourceFile(resourceType, resources)
		if err != nil {
			return fmt.Errorf("failed to generate %s resources: %w", resourceType, err)
		}
	}

	// Generate provider.tf
	fmt.Printf("Generating provider.tf...\n")
	err = tg.generateProviderFile()
	if err != nil {
		return fmt.Errorf("failed to generate provider file: %w", err)
	}

	return nil
}

// generateResourceFile generates a Terraform file for a specific resource type
func (tg *TerraformGenerator) generateResourceFile(resourceType string, resources []TerraformResource) error {
	filename := filepath.Join(tg.outputDir, fmt.Sprintf("%s.tf", resourceType))
	file, err := os.Create(filename)
	if err != nil {
		return err
	}
	defer file.Close()

	// Write file header
	fmt.Fprintf(file, "# NetBird %s resources\n# Generated by NetBird Standalone Terraformer\n\n", resourceType)

	// Write each resource
	for _, resource := range resources {
		err := tg.writeResource(file, resource)
		if err != nil {
			return err
		}
		fmt.Fprintf(file, "\n")
	}

	return nil
}

// writeResource writes a single resource or data source to the file
func (tg *TerraformGenerator) writeResource(file *os.File, resource TerraformResource) error {
	// Write resource or data source block
	if resource.IsData {
		fmt.Fprintf(file, "data \"netbird_%s\" \"%s\" {\n", resource.Type, resource.Name)
	} else {
		fmt.Fprintf(file, "resource \"netbird_%s\" \"%s\" {\n", resource.Type, resource.Name)
	}

	// Write attributes
	for key, value := range resource.Attributes {
		err := tg.writeAttribute(file, key, value, 1)
		if err != nil {
			return err
		}
	}

	fmt.Fprintf(file, "}\n")
	return nil
}

// writeAttribute writes an attribute to the file with proper formatting
func (tg *TerraformGenerator) writeAttribute(file *os.File, key string, value interface{}, indent int) error {
	// Skip read-only fields in Terraform
	if key == "id" || key == "network_type" || key == "peers" {
		return nil
	}

	indentStr := strings.Repeat("  ", indent)

	switch v := value.(type) {
	case string:
		if v != "" {
			fmt.Fprintf(file, "%s%s = \"%s\"\n", indentStr, key, tg.escapeString(v))
		}
	case bool:
		fmt.Fprintf(file, "%s%s = %t\n", indentStr, key, v)
	case int, int64, float64:
		fmt.Fprintf(file, "%s%s = %v\n", indentStr, key, v)
	case []interface{}:
		if len(v) > 0 {
			// Check if this is a list of maps (like rules)
			if len(v) > 0 {
				if _, isMap := v[0].(map[string]interface{}); isMap {
					// Handle as blocks (e.g., rules blocks)
					for _, item := range v {
						if itemMap, ok := item.(map[string]interface{}); ok {
							// Use singular form for block name
							blockName := tg.getBlockName(key)
							fmt.Fprintf(file, "%s%s {\n", indentStr, blockName)
							for k, val := range itemMap {
								err := tg.writeAttribute(file, k, val, indent+1)
								if err != nil {
									return err
								}
							}
							fmt.Fprintf(file, "%s}\n", indentStr)
						}
					}
					return nil
				}
			}

			// Handle as regular list
			fmt.Fprintf(file, "%s%s = [\n", indentStr, key)
			for _, item := range v {
				if str, ok := item.(string); ok && str != "" {
					// Check if this is a Terraform reference (starts with netbird_)
					if strings.HasPrefix(str, "netbird_") {
						// Output without quotes for Terraform references
						fmt.Fprintf(file, "%s  %s,\n", indentStr, str)
					} else {
						fmt.Fprintf(file, "%s  \"%s\",\n", indentStr, tg.escapeString(str))
					}
				}
			}
			fmt.Fprintf(file, "%s]\n", indentStr)
		}
	case []string:
		if len(v) > 0 {
			fmt.Fprintf(file, "%s%s = [\n", indentStr, key)
			for _, item := range v {
				if item != "" {
					// Check if this is a Terraform reference
					if strings.HasPrefix(item, "netbird_") {
						// Output without quotes for Terraform references
						fmt.Fprintf(file, "%s  %s,\n", indentStr, item)
					} else {
						fmt.Fprintf(file, "%s  \"%s\",\n", indentStr, tg.escapeString(item))
					}
				}
			}
			fmt.Fprintf(file, "%s]\n", indentStr)
		}
	case map[string]interface{}:
		fmt.Fprintf(file, "%s%s {\n", indentStr, key)
		for k, val := range v {
			tg.writeAttribute(file, k, val, indent+1)
		}
		fmt.Fprintf(file, "%s}\n", indentStr)
	}

	return nil
}

// getBlockName converts plural list names to singular block names
func (tg *TerraformGenerator) getBlockName(key string) string {
	switch key {
	case "rules":
		return "rule"
	case "port_ranges":
		return "port_range"
	case "sources":
		return "source"
	case "destinations":
		return "destination"
	default:
		return key
	}
}

// escapeString escapes special characters in strings for Terraform
func (tg *TerraformGenerator) escapeString(s string) string {
	s = strings.ReplaceAll(s, "\\", "\\\\")
	s = strings.ReplaceAll(s, "\"", "\\\"")
	s = strings.ReplaceAll(s, "\n", "\\n")
	s = strings.ReplaceAll(s, "\t", "\\t")
	return s
}

// generateProviderFile generates the provider.tf file
func (tg *TerraformGenerator) generateProviderFile() error {
	filename := filepath.Join(tg.outputDir, "provider.tf")
	file, err := os.Create(filename)
	if err != nil {
		return err
	}
	defer file.Close()

	providerConfig := fmt.Sprintf(`# NetBird Terraform Provider Configuration
# Generated by NetBird Terraformer

terraform {
  required_providers {
    netbird = {
      source  = "netbirdio/netbird"
      version = "~> 0.0.5"
    }
  }
}

provider "netbird" {
  management_url = "%s"
  token          = "%s"
}
`, tg.config.ServerURL, tg.config.APIToken)

	fmt.Fprint(file, providerConfig)
	return nil
}

func (tg *TerraformGenerator) queueTerraformImport(resourceType, name string, resourceID string) {
	if resourceID == "" {
		fmt.Printf("  Warning: No ID found for %s resource %s, skipping terraform import\n", resourceType, name)
		return
	}

	resourceAddress := fmt.Sprintf("netbird_%s.%s", resourceType, name)

	tg.importCommands = append(tg.importCommands, ImportCommand{
		ResourceAddress: resourceAddress,
		ResourceID:      resourceID,
	})

	fmt.Printf("  Queued terraform import for %s\n", resourceAddress)
}

// RunTerraformImports executes all queued terraform import commands
func (tg *TerraformGenerator) RunTerraformImports() error {
	if len(tg.importCommands) == 0 {
		fmt.Printf("No terraform imports to run\n")
		return nil
	}

	fmt.Printf("\nRunning terraform imports...\n")

	fmt.Printf("Running terraform init...\n")
	err := TerraformInit(tg.outputDir)
	if err != nil {
		return fmt.Errorf("terraform init failed: %w", err)
	}

	successCount := 0
	for _, cmd := range tg.importCommands {
		fmt.Printf("Importing %s...\n", cmd.ResourceAddress)
		err := TerraformImport(tg.outputDir, cmd.ResourceAddress, cmd.ResourceID)
		if err != nil {
			fmt.Printf("  Warning: terraform import failed for %s: %v\n", cmd.ResourceAddress, err)
		} else {
			fmt.Printf("  Successfully imported %s\n", cmd.ResourceAddress)
			successCount++
		}
	}

	fmt.Printf("\nTerraform import completed: %d/%d successful\n", successCount, len(tg.importCommands))
	return nil
}

func (tg *TerraformGenerator) GenerateImportScript() error {
	if len(tg.importCommands) == 0 {
		for _, resource := range tg.resources {
			if !resource.IsData && resource.ID != "" {
				resourceAddress := fmt.Sprintf("netbird_%s.%s", resource.Type, resource.Name)
				tg.importCommands = append(tg.importCommands, ImportCommand{
					ResourceAddress: resourceAddress,
					ResourceID:      resource.ID,
				})
			}
		}
	}

	if len(tg.importCommands) == 0 {
		return nil
	}

	scriptPath := filepath.Join(tg.outputDir, "import.sh")
	file, err := os.Create(scriptPath)
	if err != nil {
		return err
	}
	defer file.Close()

	err = os.Chmod(scriptPath, 0755)
	if err != nil {
		return err
	}

	fmt.Fprintln(file, "#!/bin/bash")
	fmt.Fprintln(file, "# NetBird Terraform Import Script")
	fmt.Fprintln(file, "# Generated by NetBird Standalone Terraformer")
	fmt.Fprintln(file, "")
	fmt.Fprintln(file, "set -e")
	fmt.Fprintln(file, "")
	fmt.Fprintln(file, "echo \"Running terraform init...\"")
	fmt.Fprintln(file, "terraform init")
	fmt.Fprintln(file, "")
	fmt.Fprintln(file, "echo \"Running terraform imports...\"")

	for _, cmd := range tg.importCommands {
		fmt.Fprintf(file, "echo \"Importing %s...\"\n", cmd.ResourceAddress)
		fmt.Fprintf(file, "terraform import \"%s\" \"%s\"\n", cmd.ResourceAddress, cmd.ResourceID)
		fmt.Fprintln(file, "")
	}

	fmt.Fprintln(file, "echo \"All imports completed!\"")

	return nil
}

// esta funcion tiene que ser la misma que
func sanitizeResourceName(input string) string {
	name := strings.ReplaceAll(input, " ", "_")
	name = strings.ReplaceAll(name, "-", "_")
	name = strings.ReplaceAll(name, ".", "_")
	name = strings.ReplaceAll(name, "/", "_")
	name = strings.ReplaceAll(name, "@", "_")

	name = strings.ReplaceAll(name, "(", "")
	name = strings.ReplaceAll(name, ")", "")
	name = strings.ReplaceAll(name, ",", "")
	name = strings.ReplaceAll(name, ":", "")

	name = strings.ToLower(name)

	for strings.Contains(name, "__") {
		name = strings.ReplaceAll(name, "__", "_")
	}

	name = strings.Trim(name, "_")

	if len(name) > 0 && (name[0] >= '0' && name[0] <= '9') {
		name = "resource_" + name
	}

	if name == "" {
		name = "unnamed_resource"
	}

	return name
}

type GroupMapping struct {
	ID           string `json:"id"`
	Name         string `json:"name"`
	ResourceName string `json:"terraform_resource_name"`
}

func (tg *TerraformGenerator) GenerateGroupMapping() error {
	mappings := make([]GroupMapping, 0)

	for _, resource := range tg.resources {
		if resource.Type == "group" {
			if name, exists := resource.Attributes["name"]; exists {
				if nameStr, ok := name.(string); ok {
					// We don't have the actual ID stored, but we can note this in the output
					mappings = append(mappings, GroupMapping{
						ID:           "<!-- ID will be available after terraform apply -->",
						Name:         nameStr,
						ResourceName: resource.Name,
					})
				}
			}
		}
	}

	mappingPath := filepath.Join(tg.outputDir, "group_mappings.json")
	file, err := os.Create(mappingPath)
	if err != nil {
		return err
	}
	defer file.Close()

	fmt.Fprintln(file, "{")
	fmt.Fprintln(file, "  \"_note\": \"To get actual group IDs, run 'terraform show' after 'terraform apply'\",")
	fmt.Fprintln(file, "  \"_usage\": \"Use netbird_group.<resource_name>.id in auto_groups for new users\",")
	fmt.Fprintln(file, "  \"groups\": [")

	for i, mapping := range mappings {
		fmt.Fprintf(file, "    {\n")
		fmt.Fprintf(file, "      \"name\": %q,\n", mapping.Name)
		fmt.Fprintf(file, "      \"terraform_resource\": %q,\n", mapping.ResourceName)
		fmt.Fprintf(file, "      \"terraform_reference\": \"netbird_group.%s.id\"\n", mapping.ResourceName)
		if i < len(mappings)-1 {
			fmt.Fprintf(file, "    },\n")
		} else {
			fmt.Fprintf(file, "    }\n")
		}
	}

	fmt.Fprintln(file, "  ]")
	fmt.Fprintln(file, "}")

	return nil
}
